axis_count = 1
            if tags and start_date and end_date:
                servername = "grape"  # 設定 PI 伺服器名稱
                with PI.PIServer(server=servername) as server:
                    points = server.search(tags)  # 搜尋所選的 PI tags
                    if len(points) > 0:
                        series = []
                        for p in points:
                            # 使用選擇的頻率取樣數據
                            sampling_interval = '30m'  # 默認為 30 分鐘
                            if interval == 'd':
                                sampling_interval = '30m'
                            elif interval == 'h':
                                sampling_interval = '30m'
                            elif interval == '5m':
                                sampling_interval = '5m'  # 若選擇 "5m" 則設置為 5 分鐘
                            elif interval == '1m':
                                sampling_interval = '1m'  # 若選擇 "1m" 則設置為 1 分鐘

                            data = p.interpolated_values(
                                start_time=start_date,
                                end_time=end_date,
                                interval=sampling_interval
                            )
                            
                            # 將數據轉換為 DataFrame 並重新設置索引
                            interpolated_data = pd.DataFrame(data).reset_index()
                            interpolated_data.columns = ['Timestamp', p.name]
                            
                            # 將非數字型資料轉換為 None
                            def convert_to_numeric(val):
                                try:
                                    return float(val)
                                except (ValueError, TypeError):
                                    return None  # 如果無法轉換，返回 None
                            
                            interpolated_data[p.name] = interpolated_data[p.name].apply(convert_to_numeric)
                            interpolated_data['Timestamp'] = pd.to_datetime(interpolated_data['Timestamp'])
                            interpolated_data.set_index('Timestamp', inplace=True)

                            # 根據使用者選擇的 interval 將數據重新取樣
                            if interval == 'd':  # 若選擇每日資料
                                resampled_data = interpolated_data.resample('1D').mean()
                            elif interval == 'h':  # 若選擇每小時資料
                                resampled_data = interpolated_data.resample('1H').mean()
                            elif interval == '5m':  # 若選擇5m資料
                                resampled_data = interpolated_data.resample('5min').mean()
                            else:  # 否則1m
                                resampled_data = interpolated_data

                            series.append(resampled_data)  # 將每個 Tag 的數據加入 series 清單

                        # 合併所有 PI tags 數據
                        df = pd.concat(series, axis=1)
                        print(df)
                        df.to_excel('PI.xlsx', index=False)

                        # 設定顏色循環，避免顏色數量限制
                        color_idx = 0
                        for tag in tags:
                            if tag in df.columns:
                                fig.add_trace(go.Scatter(x=df.index, 
                                                        y=df[tag], 
                                                        mode='lines', 
                                                        name=tag,
                                                        line=dict(color=color_palette[color_idx % len(color_palette)]),  
                                                        yaxis='y' + str(axis_count),
                                                        hovertemplate='Time: %{x}<br>Value: %{y:.2f}'
                                                        ))

                                # 設定額外的 Y 軸屬性
                                fig.update_layout(
                                        yaxis=dict(side='right',
                                        titlefont=dict(color=color_palette[color_idx % len(color_palette)]),
                                        tickfont=dict(color=color_palette[color_idx % len(color_palette)])),

                                    **{'yaxis' + str(axis_count + 1): dict(
                                        titlefont=dict(color=color_palette[color_idx % len(color_palette)]),
                                        tickfont=dict(color=color_palette[color_idx % len(color_palette)]),
                                        anchor="free",
                                        overlaying='y',
                                        side="right",
                                        position=1-(0.04*(axis_count))
                                    )}
                                )
