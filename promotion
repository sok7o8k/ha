app.layout = dbc.Container([
    dbc.Row([
        dbc.Col([
            dbc.Card([
                dbc.CardHeader("選擇日期"),
                dbc.CardBody([
                    dmc.DateRangePicker(
                        id='date-picker',
                        minDate='2009-01-01',
                        maxDate=(datetime.now() + timedelta(days=1)).strftime('%Y-%m-%d'),
                        value=[
                            (datetime.now() - timedelta(days=30)).strftime('%Y-%m-%d'),
                            (datetime.now() + timedelta(days=1)).strftime('%Y-%m-%d')
                        ],
                        label="日期範圍",
                        fullWidth=True
                    ),
                ])
            ], className="mb-3"),
            dbc.Card([
                dbc.CardHeader("選擇Tank"),
                dbc.CardBody([
                    dcc.Dropdown(
                        id='tank-picker',
                        options=[{'label': i, 'value': i} for i in tanks],
                        value=None,
                        placeholder="選擇 Tank ID"
                    ),
                ])
            ]),
        ]),
    ]),
    dcc.Store(id='filtered-data-melting'),  # 用於緩存 Melting Loss 資料
    dcc.Store(id='filtered-data-finishing'),  # 用於緩存 Finishing Loss 資料
    dcc.Graph(id="combined-graph")
])

@app.callback(
    [Output("filtered-data-melting", "data"),
     Output("filtered-data-finishing", "data")],
    [Input("date-picker", "value"),
     Input("tank-picker", "value")]
)
def query_data(date_range, tank):
    if not date_range or not tank:
        raise PreventUpdate  # 如果條件不完整，則不觸發查詢

    start_date, end_date = map(pd.to_datetime, date_range)

    # 查詢 Melting Loss 資料
    query_m = f"""
        SELECT NON EMPTY {{ [Measures].[M_Defect Loss%] }} ON COLUMNS, 
               NON EMPTY {{ ([Time Crate].[CR_Time YQMD].[CR_Date].ALLMEMBERS * 
                             [Tank].[Tank ID].[Tank ID].&[{tank}] *
                             [Defect Tracking].[Defect ID].[Defect ID].ALLMEMBERS) }} 
               DIMENSION PROPERTIES MEMBER_CAPTION, MEMBER_UNIQUE_NAME 
        ON ROWS 
        FROM ( SELECT ({{ [Time Crate].[CR_Date].&[{start_date:%Y-%m-%d}] :
                             [Time Crate].[CR_Date].&[{end_date:%Y-%m-%d}] }}) 
               ON COLUMNS 
               FROM [PPD_Actual]) 
        WHERE ([Time Crate].[CR_Date].CurrentMember)
        CELL PROPERTIES VALUE
    """
    with Pyadomd(conn_str) as conn:
        with conn.cursor().execute(query_m) as cur:
            df_m = pd.DataFrame(cur.fetchall(), columns=[col.name for col in cur.description])

    # 查詢 Finishing Loss 資料
    query_f = f"""
        SELECT NON EMPTY {{ [Measures].[F_Defect Loss%] }} ON COLUMNS, 
               NON EMPTY {{ ([Time Crate].[CR_Time YQMD].[CR_Date].ALLMEMBERS * 
                             [Tank].[Tank ID].[Tank ID].&[{tank}] *
                             [Defect Tracking].[Defect ID].[Defect ID].ALLMEMBERS) }} 
               DIMENSION PROPERTIES MEMBER_CAPTION, MEMBER_UNIQUE_NAME 
        ON ROWS 
        FROM ( SELECT ({{ [Time Crate].[CR_Date].&[{start_date:%Y-%m-%d}] :
                             [Time Crate].[CR_Date].&[{end_date:%Y-%m-%d}] }}) 
               ON COLUMNS 
               FROM [PPD_Actual]) 
        WHERE ([Time Crate].[CR_Date].CurrentMember)
        CELL PROPERTIES VALUE
    """
    with Pyadomd(conn_str) as conn:
        with conn.cursor().execute(query_f) as cur:
            df_f = pd.DataFrame(cur.fetchall(), columns=[col.name for col in cur.description])

    # 數據清理
    df_cleaned_m = clean_data(df_m)
    df_cleaned_f = clean_data(df_f)

    # 將數據轉換為字典格式返回
    return df_cleaned_m.to_dict("records"), df_cleaned_f.to_dict("records")

@app.callback(
    Output("combined-graph", "figure"),
    [Input("filtered-data-melting", "data"),
     Input("filtered-data-finishing", "data"),
     Input("loss-type", "value"),
     Input("defect-picker", "value")]
)
def update_combined_graph(data_m, data_f, loss_type, defect):
    fig = go.Figure()

    # 將資料還原為 DataFrame
    df_m = pd.DataFrame(data_m) if data_m else pd.DataFrame()
    df_f = pd.DataFrame(data_f) if data_f else pd.DataFrame()

    # 選擇對應數據
    if loss_type == "melting":
        filtered_df = df_m
    elif loss_type == "finishing":
        filtered_df = df_f
    elif loss_type == "melting+finishing":
        filtered_df = pd.concat([df_m, df_f])
    else:
        raise PreventUpdate

    # 過濾 Defect
    if defect:
        filtered_df = filtered_df[filtered_df["Defect ID"].isin(defect)]

    # 繪圖
    for selected_defect in filtered_df["Defect ID"].unique():
        defect_df = filtered_df[filtered_df["Defect ID"] == selected_defect]
        fig.add_trace(go.Bar(
            x=defect_df["CR_Date"],
            y=defect_df["Loss%"],
            name=selected_defect
        ))

    fig.update_layout(barmode="stack")
    return fig

def clean_data(df):
    """
    清理從資料庫查詢出來的 DataFrame 資料
    :param df: 原始 DataFrame
    :return: 清理後的 DataFrame
    """
    # 移除以 [MEMBER_UNIQUE_NAME] 結尾的欄位
    cleaned_df = df.loc[:, [col for col in df.columns if not col.endswith("[MEMBER_UNIQUE_NAME]")]]
    
    # 去除 [MEMBER_CAPTION] 後綴，並提取欄位名稱的主體部分
    cleaned_df.columns = [
        col.split(".")[-1][1:-1] if col.endswith("[MEMBER_CAPTION]") else col
        for col in cleaned_df.columns
    ]
    
    # 確保日期列是 datetime 格式
    if "CR_Date" in cleaned_df.columns:
        cleaned_df["CR_Date"] = pd.to_datetime(cleaned_df["CR_Date"], errors="coerce")
    
    return cleaned_df


