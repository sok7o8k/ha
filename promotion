@app.callback(
    Output("combined-graph", "figure"),
    Input("tags", "value"),
    Input("date-picker", "start_date"),
    Input("date-picker", "end_date"),
    Input("interval", "value"),
    Input("tank-picker", "value"),
)
def update_combined_graph(tags, start_date, end_date, interval, tank):
    # 創建空的圖表
    fig = go.Figure(layout=dict(colorway=px.colors.qualitative.Plotly))
    axis_count = 2

    # 堆疊柱狀圖部分
    start_date = pd.to_datetime(start_date)
    end_date = pd.to_datetime(end_date)
    filtered_df = df_cleaned[
        (pd.to_datetime(df_cleaned["Date"]) >= start_date) &
        (pd.to_datetime(df_cleaned["Date"]) <= end_date) &
        (df_cleaned["Tank ID"] == tank)
    ]

    for defect in filtered_df['Defect ID'].unique():
        df_defect = filtered_df[filtered_df['Defect ID'] == defect]
        fig.add_trace(go.Bar(x=df_defect["Date"], 
                             y=df_defect["M_Defect Loss%"], 
                             name=defect))

    fig.update_layout(barmode='stack')

    # 添加PI Tags的趨勢線
    if tags and start_date and end_date and interval:
        servername = "grape"
        with PI.PIServer(server=servername) as server:
            points = server.search(tags)
            if len(points) > 0:
                series = []
                for p in points:
                    # 使用 recorded 方法來獲取原始數據
                    data = p.recorded_values(
                        start_time=start_date,
                        end_time=end_date
                    )

                    # 提取時間和數據
                    recorded_data = pd.DataFrame(data).reset_index()
                    recorded_data.columns = ['Timestamp', p.name]

                    # 處理非數字型數據（如 AFEnumerationValue），嘗試將它們轉換成字符串或其他可用數值
                    def convert_to_numeric(val):
                        try:
                            return float(val)
                        except (ValueError, TypeError):
                            return None  # 如果無法轉換，返回 None

                    recorded_data[p.name] = recorded_data[p.name].apply(convert_to_numeric)

                    # 設定時間戳
                    recorded_data['Timestamp'] = pd.to_datetime(recorded_data['Timestamp'])
                    recorded_data.set_index('Timestamp', inplace=True)

                    # 計算時間加權平均
                    def time_weighted_average(dataframe):
                        dataframe['TimeDiff'] = dataframe.index.to_series().diff().dt.total_seconds().fillna(0)
                        # 將第一個數據點的時間差設置為0，避免出現 NaN
                        dataframe.iloc[0, dataframe.columns.get_loc('TimeDiff')] = 0

                        # 將時間差與數據值相乘，得到加權值
                        dataframe['WeightedValue'] = dataframe[p.name] * dataframe['TimeDiff']

                        # 計算總加權值和總時間差
                        total_weighted_value = dataframe['WeightedValue'].sum()
                        total_time = dataframe['TimeDiff'].sum()

                        # 避免除以零的情況
                        if total_time > 0:
                            return total_weighted_value / total_time
                        else:
                            return None

                    # 重新取樣數據並計算時間加權平均
                    interval_mapping = {
                        "d": "1D",  # 天
                        "h": "1H",  # 小時
                        "m": "1T",  # 分鐘
                        "s": "1S",  # 秒
                    }

                    if interval in interval_mapping:
                        # 使用 pandas 的 resample 來根據選擇的 interval 重新取樣數據
                        resampled_data = recorded_data.resample(interval_mapping[interval]).apply(time_weighted_average)
                    else:
                        resampled_data = recorded_data  # 如果沒有指定 interval，使用原始數據

                    series.append(resampled_data)

                # 合併所有 PI tags 數據
                df = pd.concat(series, axis=1)

                # 處理時間格式
                df['Timestamp'] = df.index
                df['Timestamp'] = pd.to_datetime(df['Timestamp'])

                axis_count = 2
                for tag in tags:
                    if tag in df.columns:
                        fig.add_trace(go.Scatter(x=df["Timestamp"], 
                                                y=df[tag], 
                                                mode='lines', 
                                                name=tag,
                                                line=dict(color=fig['layout']['colorway'][axis_count + 1]),  
                                                yaxis='y' + str(axis_count)))

                        fig.update_layout(
                            **{'yaxis' + str(axis_count): dict(
                                titlefont=dict(color=fig['layout']['colorway'][axis_count + 1]),
                                tickfont=dict(color=fig['layout']['colorway'][axis_count + 1]),
                                anchor="free",
                                overlaying= 'y',
                                side="right",
                                position=1-(0.04*(axis_count-1))
                            )}
                        )

                        axis_count += 1

    fig.update_layout(
        title=f'{tank} Performance and Process trend',
        xaxis=dict(domain=[0, 1-((axis_count-2)*0.04)], title='Date'),
        yaxis=dict(tickformat='.1%'),
        yaxis_title='Value',
        height=500,
        margin=dict(b=0, l=0, r=90, t=90+30*(axis_count/3)),
        dragmode='zoom',
        legend_title_text=None,
        legend=dict(
            orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1
        ),
    )

    return fig
