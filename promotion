@app.callback(
    [Output("defect-picker", "options"),  # 更新 defect-picker 的選項
     Output("defect-picker", "value")],  # 更新 defect-picker 的預設值
    Input("loss-type", "value"),          # 當 loss-type 改變時觸發
    Input("tank-picker", "value"),        # 當 tank 改變時也觸發
    Input("date-picker", "value")         # 當日期範圍改變時觸發
)
def update_defect_picker(loss_type, tank, date_range):
    # 確保日期範圍有效
    if not date_range or len(date_range) != 2:
        raise PreventUpdate

    start_date, end_date = map(pd.to_datetime, date_range)

    # 根據 loss_type 選擇數據來源並篩選日期和 Tank
    if loss_type == 'melting':
        filtered_df = df_cleaned_M[
            (df_cleaned_M["Tank ID"] == tank) &
            (df_cleaned_M["CR_Date"] >= start_date) &
            (df_cleaned_M["CR_Date"] <= end_date)
        ]
    elif loss_type == 'finishing':
        filtered_df = df_cleaned_F[
            (df_cleaned_F["Tank ID"] == tank) &
            (df_cleaned_F["CR_Date"] >= start_date) &
            (df_cleaned_F["CR_Date"] <= end_date)
        ]
    else:
        return [], []  # 無效 loss_type 返回空選項

    # 獲取篩選後的所有 Defect ID 並去重
    all_defects = filtered_df["Defect ID"].dropna().unique()
    defect_options = [{"label": defect, "value": defect} for defect in all_defects]

    # 預設選中所有篩選出的 Defect
    default_values = list(all_defects)

    return defect_options, default_values
