@app.callback(
    Output("combined-graph", "figure"),
    Input("tags", "value"),
    Input("date-picker", "start_date"),
    Input("date-picker", "end_date"),
    Input("interval", "value"),
    Input("tank-picker", "value"),
)
def update_combined_graph(tags, start_date, end_date, interval, tank):
    # 創建一個空的圖表，設定配色方案
    fig = go.Figure(layout=dict(colorway=px.colors.qualitative.Plotly))
    axis_count = 2  # 初始化Y軸數量計數器

    # 將選擇的日期範圍轉換為日期時間格式
    start_date = pd.to_datetime(start_date)
    end_date = pd.to_datetime(end_date)
    
    # 過濾 df_cleaned 中符合日期範圍和選擇的 Tank 的數據
    filtered_df = df_cleaned[
        (pd.to_datetime(df_cleaned["Date"]) >= start_date) &
        (pd.to_datetime(df_cleaned["Date"]) <= end_date) &
        (df_cleaned["Tank ID"] == tank)
    ]

    # 繪製缺陷數據的堆疊柱狀圖
    for defect in filtered_df['Defect ID'].unique():
        df_defect = filtered_df[filtered_df['Defect ID'] == defect]
        fig.add_trace(go.Bar(x=df_defect["Date"], 
                             y=df_defect["M_Defect Loss%"], 
                             name=defect))

    fig.update_layout(barmode='stack')  # 設定柱狀圖為堆疊模式

    # 如果有選擇 PI tags 且有日期範圍，則提取並繪製 PI 數據
    if tags and start_date and end_date:
        servername = "grape"  # 設定 PI 伺服器名稱
        with PI.PIServer(server=servername) as server:
            points = server.search(tags)  # 搜尋所選的 PI tags
            if len(points) > 0:
                series = []
                for p in points:
                    # 使用一分鐘間隔取樣數據
                    data = p.interpolated_values(
                        start_time=start_date,
                        end_time=end_date,
                        interval="1m"
                    )
                    # 將數據轉換為 DataFrame 並重新設置索引
                    interpolated_data = pd.DataFrame(data).reset_index()
                    interpolated_data.columns = ['Timestamp', p.name]
                    
                    # 將非數字型資料轉換為 None
                    def convert_to_numeric(val):
                        try:
                            return float(val)
                        except (ValueError, TypeError):
                            return None  # 如果無法轉換，返回 None
                    
                    interpolated_data[p.name] = interpolated_data[p.name].apply(convert_to_numeric)
                    interpolated_data['Timestamp'] = pd.to_datetime(interpolated_data['Timestamp'])
                    interpolated_data.set_index('Timestamp', inplace=True)

                    # 根據使用者選擇的 interval 將數據重新取樣
                    if interval == 'd':  # 若選擇每日資料
                        resampled_data = interpolated_data.resample('1D').mean()
                    elif interval == 'h':  # 若選擇每小時資料
                        resampled_data = interpolated_data.resample('1H').mean()
                    else:  # 否則使用原始數據（每分鐘）
                        resampled_data = interpolated_data

                    series.append(resampled_data)  # 將每個 Tag 的數據加入 series 清單

                # 合併所有 PI tags 數據
                df = pd.concat(series, axis=1)

                # 繪製每個 PI tag 的趨勢線，並添加額外的 Y 軸
                axis_count = 2
                for tag in tags:
                    if tag in df.columns:
                        fig.add_trace(go.Scatter(x=df.index, 
                                                y=df[tag], 
                                                mode='lines', 
                                                name=tag,
                                                line=dict(color=fig['layout']['colorway'][axis_count + 1]),  
                                                yaxis='y' + str(axis_count)))

                        # 設定額外的 Y 軸屬性
                        fig.update_layout(
                            **{'yaxis' + str(axis_count): dict(
                                titlefont=dict(color=fig['layout']['colorway'][axis_count + 1]),
                                tickfont=dict(color=fig['layout']['colorway'][axis_count + 1]),
                                anchor="free",
                                overlaying='y',
                                side="right",
                                position=1-(0.04*(axis_count-1))
                            )}
                        )

                        axis_count += 1  # 增加 Y 軸數量計數器

    # 更新圖表的佈局和標題
    fig.update_layout(
        title=f'{tank} Performance and Process trend',
        xaxis=dict(domain=[0, 1-((axis_count-2)*0.04)], title='Date'),
        yaxis=dict(tickformat='.1%'),
        yaxis_title='Value',
        height=500,
        margin=dict(b=0, l=0, r=90, t=90+30*(axis_count/3)),
        dragmode='zoom',
        legend_title_text=None,
        legend=dict(
            orientation="h
