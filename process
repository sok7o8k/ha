from sys import path
import plotly.graph_objects as go
import plotly.express as px
from dash import Dash, html, dcc, Input, Output, State
import dash_bootstrap_components as dbc
import pandas as pd
import PIconnect as PI
from datetime import datetime, timedelta

PI.PIConfig.DEFAULT_TIMEZONE = "Asia/Taipei"

path.append("C:\\Users\\chenk23\\Desktop\\DT2\\20240507\\03_Databases")  # 添加資料庫路徑

from pyadomd import Pyadomd

conn_str = "Provider=MSOLAP;Data Source=cgtppd;Catalog=ppd;"
query = "YOUR_MDX_QUERY_HERE"  # 把這裡換成你的完整 MDX 查詢語句

# 取得數據並清理
with Pyadomd(conn_str) as conn:
    with conn.cursor().execute(query) as cur:
        df = pd.DataFrame(cur.fetchone(), columns=[i.name for i in cur.description])

# 清理數據表
df_cleaned = df.loc[:, [c for c in df.columns if c[-20:] != "[MEMBER_UNIQUE_NAME]"]]
df_cleaned.columns = [
    c[:-17] if c[-16:] == "[MEMBER_CAPTION]" else c for c in df_cleaned.columns
]
df_cleaned.columns = [c.split(".")[-1][1:-1] for c in df_cleaned.columns]

app = Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP, dbc.icons.BOOTSTRAP])

tanks = df_cleaned["Tank ID"].unique()
defects = df_cleaned["Defect ID"].unique()

app.layout = dbc.Container([
    dbc.Row([
        dbc.Col([
            dbc.Card([
                dbc.CardHeader("選擇日期"),
                dbc.CardBody([
                    dcc.DatePickerRange(
                        id='date-picker',
                        min_date_allowed=df_cleaned['Date'].min(),
                        max_date_allowed=(datetime.now() + timedelta(days=1)).date(),
                        start_date=df_cleaned['Date'].min(),
                        end_date=(datetime.now() + timedelta(days=1)).date()
                    ),
                ])
            ], className="mb-3"),
            dbc.Card([
                dbc.CardHeader("選擇Tank"),
                dbc.CardBody([
                    dcc.Dropdown(
                        id='tank-picker',
                        options=[{'label': i, 'value': i} for i in tanks],
                        value=tanks[0]
                    ),
                ]),
            ], className="mb-3"),
            dbc.Card([
                dbc.CardHeader("選擇Defect"),
                dbc.CardBody([
                    dcc.Dropdown(
                        id='defect-picker',
                        options=[{'label': i, 'value': i} for i in defects],
                        value=defects[0]
                    ),
                ]),
            ], className="mb-3"),
        ], width=4),
    ]),
    dbc.Row([
        dbc.Col([
            dbc.Card([
                dbc.CardHeader("選擇Pi Data取值頻率"),
                dbc.CardBody([
                    dbc.RadioItems(
                        options=[
                            {"label": "Day", "value": "d"},
                            {"label": "Hour", "value": "h"},
                            {"label": "Minute", "value": "m"}
                        ],
                        value="d",
                        inline=True,
                        id="interval",
                        className="mb-3",
                    ),
                ]),
            ], className="mb-3"),
        ], width=6),
    ]),
    dbc.Row([
        dbc.Col([
            dbc.Card([
                dbc.CardHeader("選擇PI Tags"),
                dbc.CardBody([
                    html.Div([
                        dcc.Dropdown(
                            options=[],
                            multi=True,
                            id="tags",
                            className="mb-3",
                        ),
                    ]),
                ]),
            ], className="mb-3"),
        ], width=6)
    ]),
    dbc.Row([
        dbc.Col([
            dbc.Card([
                dbc.CardBody([
                    dcc.Graph(
                        id="combined-graph",
                        style={"height": "500px"},
                    ),
                ]),
            ], className="mb-3"),
        ], width=11),
    ]),
])

@app.callback(
    Output("tags", "options"), 
    Input("tank-picker", "value")
)
def update_tags_options(Tank_ID):
    tags_df = pd.read_csv("tags.csv")
    csv_tags = tags_df.loc[tags_df["tank"].str.startswith(Tank_ID), "tag"].tolist()

    with PI.PIServer(server="grape") as server:
        points = server.search(f'*{Tank_ID}*')
        pi_tags = [p.name for p in points]

    combined_tags = csv_tags + pi_tags
    return combined_tags


def query_pi_data_in_chunks(tags, start_date, end_date, interval, max_count_per_query=10000):
    all_series = []
    delta = timedelta(days=1)  # 每次查詢一天的數據
    current_start = start_date

    while current_start < end_date:
        current_end = min(current_start + delta, end_date)

        with PI.PIServer(server="grape") as server:
            points = server.search(tags)
            if len(points) > 0:
                series = []
                for p in points:
                    data = p.recorded_values(
                        start_time=current_start,
                        end_time=current_end,
                        maxCount=max_count_per_query
                    )
                    recorded_data = pd.DataFrame(data).reset_index()
                    recorded_data.columns = ['Timestamp', p.name]

                    def convert_to_numeric(val):
                        try:
                            return float(val)
                        except (ValueError, TypeError):
                            return None

                    recorded_data[p.name] = recorded_data[p.name].apply(convert_to_numeric)
                    recorded_data['Timestamp'] = pd.to_datetime(recorded_data['Timestamp'])
                    recorded_data.set_index('Timestamp', inplace=True)
                    series.append(recorded_data)

                df = pd.concat(series, axis=1)
                all_series.append(df)

        current_start = current_end

    if all_series:
        combined_df = pd.concat(all_series)
        return combined_df
    return pd.DataFrame()

@app.callback(
    Output("combined-graph", "figure"),
    Input("tags", "value"),
    Input("date-picker", "start_date"),
    Input("date-picker", "end_date"),
    Input("interval", "value"),
    Input("tank-picker", "value"),
)
def update_combined_graph(tags, start_date, end_date, interval, tank):
    fig = go.Figure(layout=dict(colorway=px.colors.qualitative.Plotly))
    axis_count = 2

    start_date = pd.to_datetime(start_date)
    end_date = pd.to_datetime(end_date)
    filtered_df = df_cleaned[
        (pd.to_datetime(df_cleaned["Date"]) >= start_date) &
        (pd.to_datetime(df_cleaned["Date"]) <= end_date) &
        (df_cleaned["Tank ID"] == tank)
    ]

    for defect in filtered_df['Defect ID'].unique():
        df_defect = filtered_df[filtered_df['Defect ID'] == defect]
        fig.add_trace(go.Bar(x=df_defect["Date"], y=df_defect["M_Defect Loss%"], name=defect))

    fig.update_layout(barmode='stack')

    if tags and start_date and end_date and interval:
        df = query_pi_data_in_chunks(tags, start_date, end_date, interval)
        axis_count = 2
        for tag in tags:
            if tag in df.columns:
                fig.add_trace(go.Scatter(x=df["Timestamp"], y=df[tag], mode='lines', name=tag))

                fig.update_layout(
                    **{'yaxis' + str(axis_count): dict(
                        titlefont=dict(color=fig['layout']['colorway'][axis_count + 1]),
                        tickfont=dict(color=fig['layout']['colorway'][axis_count + 1]),
                        anchor="free",
                        overlaying= 'y',
                        side="right",
                        position=1-(0.04*(axis_count-1))
                    )}
                )
                axis_count += 1

    fig.update_layout(
        title=f'{tank} Performance and Process trend',
        xaxis=dict(domain=[0, 1-((axis_count-2)*0.04)], title='Date'),
        yaxis=dict(tickformat='.1%'),
        yaxis_title='Value',
        height=500,
        margin=dict(b=0, l=0, r=90, t=90+30*(axis_count/3)),
        dragmode='zoom',
        legend_title_text=None,
        legend=dict(
            orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1
        ),
    )

    return fig

if __name__ == '__main__':
    app.run_server(debug=True, port='7788')
