@app.callback(
    Output("combined-graph", "figure"),
    Input("tags", "value"),
    Input("date-picker", "start_date"),
    Input("date-picker", "end_date"),
    Input("interval", "value"),
    Input("tank-picker", "value"),
)
def update_combined_graph(tags, start_date, end_date, interval, tank):
    # 創建空的圖表
    fig = go.Figure(layout=dict(colorway=px.colors.qualitative.Plotly))
    axis_count = 2

    # 堆疊柱狀圖部分
    start_date = pd.to_datetime(start_date)
    end_date = pd.to_datetime(end_date)
    filtered_df = df_cleaned[
        (pd.to_datetime(df_cleaned["Date"]) >= start_date) &
        (pd.to_datetime(df_cleaned["Date"]) <= end_date) &
        (df_cleaned["Tank ID"] == tank)
    ]

    for defect in filtered_df['Defect ID'].unique():
        df_defect = filtered_df[filtered_df['Defect ID'] == defect]
        fig.add_trace(go.Bar(x=df_defect["Date"], 
                             y=df_defect["M_Defect Loss%"], 
                             name=defect))

    fig.update_layout(barmode='stack')

    # 添加PI Tags的趨勢線 (使用 interpolated_values)
    if tags and start_date and end_date and interval:
        servername = "grape"
        with PI.PIServer(server=servername) as server:
            points = server.search(tags)
            if len(points) > 0:
                series = []
                interval_mapping = {
                    "d": "1d",  # Day
                    "h": "1h",  # Hour
                    "m": "1m"   # Minute
                }

                for p in points:
                    # 使用 interpolated 方法來獲取插值數據
                    data = p.interpolated_values(
                        start_time=start_date,
                        end_time=end_date,
                        interval=interval_mapping.get(interval, "1d")  # 預設為1天
                    )

                    # 提取時間和數據
                    interpolated_data = pd.DataFrame(data).reset_index()
                    interpolated_data.columns = ['Timestamp', p.name]

                    # 處理非數字型數據（如 AFEnumerationValue），嘗試將它們轉換成字符串或其他可用數值
                    def convert_to_numeric(val):
                        try:
                            return float(val)
                        except (ValueError, TypeError):
                            return None  # 如果無法轉換，返回 None

                    interpolated_data[p.name] = interpolated_data[p.name].apply(convert_to_numeric)

                    # 設定時間戳
                    interpolated_data['Timestamp'] = pd.to_datetime(interpolated_data['Timestamp'])
                    interpolated_data.set_index('Timestamp', inplace=True)

                    series.append(interpolated_data)

                # 合併所有 PI tags 數據
                df = pd.concat(series, axis=1)

                # 處理時間格式
                df['Timestamp'] = df.index
                df['Timestamp'] = pd.to_datetime(df['Timestamp'])

                axis_count = 2
                for tag in tags:
                    if tag in df.columns:
                        fig.add_trace(go.Scatter(x=df["Timestamp"], 
                                                y=df[tag], 
                                                mode='lines', 
                                                name=tag,
                                                line=dict(color=fig['layout']['colorway'][axis_count + 1]),  
                                                yaxis='y' + str(axis_count)))

                        fig.update_layout(
                            **{'yaxis' + str(axis_count): dict(
                                titlefont=dict(color=fig['layout']['colorway'][axis_count + 1]),
                                tickfont=dict(color=fig['layout']['colorway'][axis_count + 1]),
                                anchor="free",
                                overlaying='y',
                                side="right",
                                position=1-(0.04*(axis_count-1))
                            )}
                        )

                        axis_count += 1

    fig.update_layout(
        title=f'{tank} Performance and Process trend',
        xaxis=dict(domain=[0, 1-((axis_count-2)*0.04)], title='Date'),
        yaxis=dict(tickformat='.1%'),
        yaxis_title='Value',
        height=500,
        margin=dict(b=0, l=0, r=90, t=90+30*(axis_count/3)),
        dragmode='zoom',
        legend_title_text=None,
        legend=dict(
            orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1
        ),
    )

    return fig
