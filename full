@app.callback(
    Output("combined-graph", "figure"),
    Input("tags", "value"),
    Input("date-picker", "value"),
    Input("interval", "value"),
    Input("tank-picker", "value"),
    Input("loss-type", "value"),
    Input("defect-picker", "value"),
)
def update_combined_graph(tags, date_range, interval, tank, loss_type, defect):
    def process_loss_data(loss_type, tank, defect, start_date, end_date):
        # 與之前相同的邏輯
        if loss_type == 'melting':
            return df_cleaned_M[
                (df_cleaned_M["CR_Date"] >= start_date) &
                (df_cleaned_M["CR_Date"] <= end_date) &
                (df_cleaned_M["Tank ID"] == tank)
            ]
        elif loss_type == 'finishing':
            return df_cleaned_F[
                (df_cleaned_F["CR_Date"] >= start_date) &
                (df_cleaned_F["CR_Date"] <= end_date) &
                (df_cleaned_F["Tank ID"] == tank)
            ]
        elif loss_type == 'melting+finishing':
            filtered_df_melting = df_cleaned_M[
                (df_cleaned_M["CR_Date"] >= start_date) &
                (df_cleaned_M["CR_Date"] <= end_date) &
                (df_cleaned_M["Tank ID"] == tank)
            ]
            filtered_df_finishing = df_cleaned_F[
                (df_cleaned_F["CR_Date"] >= start_date) &
                (df_cleaned_F["CR_Date"] <= end_date) &
                (df_cleaned_F["Tank ID"] == tank)
            ]
            return pd.concat([filtered_df_melting, filtered_df_finishing])
        return None

    def get_sampling_interval(interval):
        return {
            'd': '30m',
            'h': '30m',
            '5m': '5m',
            '1m': '1m',
        }.get(interval, '30m')

    def prepare_interpolated_data(points, start_date, end_date, interval):
        # 與之前相同的邏輯
        series = []
        sampling_interval = get_sampling_interval(interval)
        for p in points:
            data = p.interpolated_values(start_time=start_date, end_time=end_date, interval=sampling_interval)
            df = pd.DataFrame(data).reset_index()
            df.columns = ['Timestamp', p.name]
            df[p.name] = pd.to_numeric(df[p.name], errors='coerce')
            df['Timestamp'] = pd.to_datetime(df['Timestamp'])
            df.set_index('Timestamp', inplace=True)
            resampled_data = df.resample(sampling_interval).mean()
            series.append(resampled_data)
        return pd.concat(series, axis=1)

    def add_pi_data_no_defect(fig, df, tags, axis_count, color_idx):
        # 第一次添加 y1 並且不設定 overlapping
        first_axis_added = False
        for tag in tags:
            if tag in df.columns:
                yaxis_name = f'y{axis_count}' if axis_count > 1 else 'y'
                fig.add_trace(go.Scatter(
                    x=df.index,
                    y=df[tag],
                    mode='lines',
                    name=tag,
                    line=dict(color=color_palette[color_idx % len(color_palette)]),
                    yaxis=yaxis_name,
                    hovertemplate='Time: %{x}<br>Value: %{y:.2f}'
                ))
                if not first_axis_added:  # 第一次設置 y1，無 overlapping 設定
                    fig.update_layout(
                        yaxis=dict(
                            titlefont=dict(color=color_palette[color_idx % len(color_palette)]),
                            tickfont=dict(color=color_palette[color_idx % len(color_palette)]),
                            side="left"  # 左側第一個 y 軸
                        )
                    )
                    first_axis_added = True
                else:  # 其他軸設置在右邊
                    fig.update_layout(
                        **{f'yaxis{axis_count}': dict(
                            titlefont=dict(color=color_palette[color_idx % len(color_palette)]),
                            tickfont=dict(color=color_palette[color_idx % len(color_palette)]),
                            anchor="free",
                            overlaying='y',
                            side="right",
                            position=1 - (0.04 * (axis_count - 1))
                        )}
                    )
                axis_count += 1
                color_idx += 1
        return axis_count, color_idx

    # 初始化
    fig = go.Figure()
    axis_count = 2

    # 檢查日期範圍
    if not date_range or len(date_range) != 2:
        raise PreventUpdate
    start_date, end_date = map(pd.to_datetime, date_range)

    # 處理 Loss 數據
    if loss_type in ['melting', 'finishing', 'melting+finishing']:
        filtered_df = process_loss_data(loss_type, tank, defect, start_date, end_date)
        if defect:  # 有選擇 defect
            final_df = filtered_df[filtered_df['Defect ID'].isin(defect)]
            for selected_defect in defect:
                df_defect = final_df[final_df['Defect ID'] == selected_defect]
                loss_column = (
                    "M_Defect Loss%" if selected_defect in df_cleaned_M["Defect ID"].unique()
                    else "F_Defect Loss%"
                )
                fig.add_trace(go.Bar(
                    x=df_defect["CR_Date"],
                    y=df_defect[loss_column],
                    name=selected_defect,
                    marker_color=defect_colors.get(selected_defect)
                ))
            fig.update_layout(barmode='stack')
        elif tags and start_date and end_date:  # 無 defect，但有 tags
            servername = "grape"
            with PI.PIServer(server=servername) as server:
                points = server.search(tags)
                if points:
                    df = prepare_interpolated_data(points, start_date, end_date, interval)
                    axis_count, _ = add_pi_data_no_defect(fig, df, tags, axis_count, 0)

    # 更新圖表布局
    fig.update_layout(
        showlegend=True,
        title=f'{tank} Performance and Process Chart',
        xaxis=dict(domain=[0, 1 - ((axis_count - 1) * 0.04)], tickformat='%Y-%m-%d\n%H:%M:%S', title='Date'),
        yaxis_title='Value',
        height=500,
        margin=dict(b=0, l=0, r=90, t=90 + 30 * (axis_count / 3)),
        dragmode='zoom',
        legend_title_text=None,
        legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1),
    )

    return fig
                            # 將非數字型資料轉換為 None
                            def convert_to_numeric(val):
                                try:
                                    return float(val)
                                except (ValueError, TypeError):
                                    return None  # 如果無法轉換，返回 None
                            
                            interpolated_data[p.name] = interpolated_data[p.name].apply(convert_to_numeric)
                            interpolated_data['Timestamp'] = pd.to_datetime(interpolated_data['Timestamp'])
                            interpolated_data.set_index('Timestamp', inplace=True)

                            # 根據使用者選擇的 interval 將數據重新取樣
                            if interval == 'd':  # 若選擇每日資料
                                resampled_data = interpolated_data.resample('1D').mean()
                            elif interval == 'h':  # 若選擇每小時資料
                                resampled_data = interpolated_data.resample('1H').mean()
                            elif interval == '5m':  # 若選擇5m資料
                                resampled_data = interpolated_data.resample('5min').mean()
                            else:  # 否則1m
                                resampled_data = interpolated_data

                            series.append(resampled_data)  # 將每個 Tag 的數據加入 series 清單

                        # 合併所有 PI tags 數據
                        df = pd.concat(series, axis=1)
                        print(df)
                        df.to_excel('PI.xlsx', index=False)

                        # 設定顏色循環，避免顏色數量限制
                        color_idx = 0
                        for tag in tags:
                            if tag in df.columns:
                                fig.add_trace(go.Scatter(x=df.index, 
                                                        y=df[tag], 
                                                        mode='lines', 
                                                        name=tag,
                                                        line=dict(color=color_palette[color_idx % len(color_palette)]),  
                                                        yaxis='y' + str(axis_count),
                                                        hovertemplate='Time: %{x}<br>Value: %{y:.2f}'
                                                        ))

                                # 設定額外的 Y 軸屬性
                                fig.update_layout(
                                        yaxis=dict(side='right',
                                        titlefont=dict(color=color_palette[color_idx % len(color_palette)]),
                                        tickfont=dict(color=color_palette[color_idx % len(color_palette)])),

                                    **{'yaxis' + str(axis_count + 1): dict(
                                        titlefont=dict(color=color_palette[color_idx % len(color_palette)]),
                                        tickfont=dict(color=color_palette[color_idx % len(color_palette)]),
                                        anchor="free",
                                        overlaying='y',
                                        side="right",
                                        position=1-(0.04*(axis_count))
                                    )}
                                )

                                axis_count += 1  # 增加 Y 軸數量計數器
                                color_idx += 1  # 更新顏色索引

            
    else:
        pass



    # 更新圖表的佈局和標題
    fig.update_layout(
        showlegend=True,
        title=f'{tank} Performance and Process Chart',
        xaxis=dict(domain=[0, 1-((axis_count-1)*0.04)], 
                   tickformat='%Y-%m-%d\n%H:%M:%S',
                   title='Date'),
        yaxis=dict(tickformat='.2%'),
        yaxis_title='Value',
        height=500,
        margin=dict(b=0, l=0, r=90, t=90+30*(axis_count/3)),
        dragmode='zoom',
        legend_title_text=None,
        legend=dict(
            orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1
        ),
    )

    return fig  # 回傳更新後的圖表
