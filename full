from plotly.subplots import make_subplots
import plotly.graph_objects as go

@app.callback(
    Output("combined-graph", "figure"),
    Input("tags", "value"),
    Input("date-picker", "value"),
    Input("interval", "value"),
    Input("tank-picker", "value"),
    Input("loss-type", "value"),
    Input("defect-picker", "value"),
)
def update_combined_graph(tags, date_range, interval, tank, loss_type, defect):
    # 創建子圖
    fig = make_subplots(
        rows=2, cols=1,  # 設定兩個子圖
        shared_xaxes=True,  # 共享X軸
        vertical_spacing=0.1,  # 子圖之間的空間
        subplot_titles=("PI Tags Data", "Defects Data"),  # 每個子圖的標題
        row_heights=[0.6, 0.4]  # 設定每個子圖的高度
    )

    # 設置 Y 軸
    axis_count = 2  # 目前有兩個子圖
    fig.update_layout(
        yaxis=dict(
            title='PI Tags Values',
            tickformat='.2%',
        ),
        yaxis2=dict(
            title='Defect Loss%',
            tickformat='.2%',
        ),
    )

    # 處理 PI Tags 數據
    if tags and date_range:
        start_date, end_date = map(pd.to_datetime, date_range)
        servername = "grape"
        with PI.PIServer(server=servername) as server:
            points = server.search(tags)  # 根據 tags 搜尋 PI 數據
            if len(points) > 0:
                series = []
                color_idx = 0
                for p in points:
                    data = p.interpolated_values(
                        start_time=start_date,
                        end_time=end_date,
                        interval=interval
                    )
                    interpolated_data = pd.DataFrame(data).reset_index()
                    interpolated_data.columns = ['Timestamp', p.name]
                    interpolated_data.set_index('Timestamp', inplace=True)

                    # 將 PI 數據加入子圖1（PI Tags Data）
                    fig.add_trace(go.Scatter(
                        x=interpolated_data.index,
                        y=interpolated_data[p.name],
                        mode='lines',
                        name=p.name,
                        line=dict(color=color_palette[color_idx % len(color_palette)]),
                        yaxis='y1',  # 使用子圖1的y軸
                    ), row=1, col=1)

                    color_idx += 1

    # 處理缺陷數據 (Defects)
    if defect and date_range:
        start_date, end_date = map(pd.to_datetime, date_range)
        final_df = df_cleaned_M[
            (df_cleaned_M["Tank ID"] == tank) & 
            (df_cleaned_M["CR_Date"] >= start_date) &
            (df_cleaned_M["CR_Date"] <= end_date)
        ]
        for selected_defect in defect:
            df_defect = final_df[final_df['Defect ID'] == selected_defect]
            loss_column = "M_Defect Loss%" if selected_defect in df_cleaned_M["Defect ID"].unique() else "F_Defect Loss%"
            fig.add_trace(go.Bar(
                x=df_defect["CR_Date"],
                y=df_defect[loss_column],
                name=selected_defect,
                marker_color=defect_colors.get(selected_defect),
                yaxis='y2',  # 使用子圖2的y軸
            ), row=2, col=1)

    # 更新圖表布局
    fig.update_layout(
        showlegend=True,
        title=f'{tank} Performance and Process Chart',
        xaxis=dict(
            domain=[0, 1],
            tickformat='%Y-%m-%d\n%H:%M:%S',
            title='Date'
        ),
        height=600,
        margin=dict(b=0, l=0, r=90, t=90),
        dragmode='zoom',
        legend_title_text=None,
        legend=dict(
            orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1
        ),
    )

    return fig
