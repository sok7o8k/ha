def update_combined_graph(tags, date_range, interval, tank, loss_type, defect):
    # 創建一個空的圖表，設定固定顏色板
    fig = go.Figure()
    
    axis_count = 2  # 初始化Y軸數量計數器

    #確保 date_range為有效值
    if not date_range or len(date_range) != 2:
        raise PreventUpdate 
    start_date, end_date = map(pd.to_datetime, date_range)  # 轉換為 datetime 對象

    # # 過濾 df_cleaned_M 中符合日期範圍和選擇的 Tank 的數據
    # filtered_df = df_cleaned_M[
    #     (df_cleaned_M["CR_Date"] >= start_date) &
    #     (df_cleaned_M["CR_Date"] <= end_date) &
    #     (df_cleaned_M["Tank ID"] == tank)
    # ]

    # # 繪製缺陷數據的堆疊柱狀圖
    # for defect in filtered_df['Defect ID'].unique():
    #     df_defect = filtered_df[filtered_df['Defect ID'] == defect]
    #     fig.add_trace(go.Bar(x=df_defect["CR_Date"], 
    #                          y=df_defect["M_Defect Loss%"], 
    #                          name=defect))

    # fig.update_layout(barmode='stack')  # 設定柱狀圖為堆疊模式



    # 選擇對應數據源並繪製 Loss 部分
    if loss_type != 'none':
        if loss_type == 'melting':
            filtered_df = df_cleaned_M[
                (df_cleaned_M["CR_Date"] >= start_date) &
                (df_cleaned_M["CR_Date"] <= end_date) &
                (df_cleaned_M["Tank ID"] == tank)
            ]
        elif loss_type == 'finishing':
            filtered_df = df_cleaned_F[
                (df_cleaned_F["CR_Date"] >= start_date) &
                (df_cleaned_F["CR_Date"] <= end_date) &
                (df_cleaned_F["Tank ID"] == tank)
            ]
        print(filtered_df)
        # 過濾選定的 Defect ID 並繪製堆疊柱狀圖
        for defect in filtered_df['Defect ID'].unique():
            if isinstance(defect, str):
                defect = [defect]
            filtered_df = filtered_df[filtered_df["Defect ID"].isin(defect)]
            fig.add_trace(go.Bar(
                x=filtered_df["CR_Date"],
                y=filtered_df["M_Defect Loss%"] if loss_type == 'melting' else filtered_df["F_Defect Loss%"],
                name=defect
            ))
