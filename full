@app.callback(
    [Output("defect-picker", "options"),  # 更新 defect-picker 的選項
     Output("defect-picker", "value")],  # 更新 defect-picker 的預設值
    Input("loss-type", "value"),         # 當 loss-type 改變時觸發
    Input("tank-picker", "value"),       # 當 tank 改變時也觸發
    Input("date-picker", "value")        # 當日期範圍改變時觸發
)
def update_defect_picker(loss_type, tank, date_range):
    if not date_range or len(date_range) != 2:
        raise PreventUpdate

    start_date, end_date = map(pd.to_datetime, date_range)

    # 合并 melting 和 finishing 数据源
    if loss_type == 'melting loss + finishing loss':
        filtered_df_melting = df_cleaned_M[
            (df_cleaned_M["Tank ID"] == tank) &
            (df_cleaned_M["CR_Date"] >= start_date) &
            (df_cleaned_M["CR_Date"] <= end_date)
        ]
        filtered_df_finishing = df_cleaned_F[
            (df_cleaned_F["Tank ID"] == tank) &
            (df_cleaned_F["CR_Date"] >= start_date) &
            (df_cleaned_F["CR_Date"] <= end_date)
        ]
        filtered_df = pd.concat([filtered_df_melting, filtered_df_finishing])
    elif loss_type == 'melting':
        filtered_df = df_cleaned_M[
            (df_cleaned_M["Tank ID"] == tank) &
            (df_cleaned_M["CR_Date"] >= start_date) &
            (df_cleaned_M["CR_Date"] <= end_date)
        ]
    elif loss_type == 'finishing':
        filtered_df = df_cleaned_F[
            (df_cleaned_F["Tank ID"] == tank) &
            (df_cleaned_F["CR_Date"] >= start_date) &
            (df_cleaned_F["CR_Date"] <= end_date)
        ]
    else:
        return [], []

    # 获取唯一的 Defect ID 选项
    all_defects = filtered_df["Defect ID"].dropna().unique()
    defect_options = [{"label": defect, "value": defect} for defect in all_defects]

    # 默认选中所有 Defect
    default_values = list(all_defects)

    return defect_options, default_values


@app.callback(
    Output("combined-graph", "figure"),
    Input("tags", "value"),
    Input("date-picker", "value"),
    Input("interval", "value"),
    Input("tank-picker", "value"),
    Input("loss-type", "value"),
    Input("defect-picker", "value"),
)
def update_combined_graph(tags, date_range, interval, tank, loss_type, defect):
    fig = go.Figure()
    axis_count = 2

    if not date_range or len(date_range) != 2:
        raise PreventUpdate
    start_date, end_date = map(pd.to_datetime, date_range)

    # 处理 Loss 数据
    if loss_type in ['melting', 'finishing', 'melting loss + finishing loss']:
        if loss_type == 'melting':
            filtered_df = df_cleaned_M[
                (df_cleaned_M["CR_Date"] >= start_date) &
                (df_cleaned_M["CR_Date"] <= end_date) &
                (df_cleaned_M["Tank ID"] == tank)
            ]
        elif loss_type == 'finishing':
            filtered_df = df_cleaned_F[
                (df_cleaned_F["CR_Date"] >= start_date) &
                (df_cleaned_F["CR_Date"] <= end_date) &
                (df_cleaned_F["Tank ID"] == tank)
            ]
        elif loss_type == 'melting loss + finishing loss':
            filtered_df_melting = df_cleaned_M[
                (df_cleaned_M["CR_Date"] >= start_date) &
                (df_cleaned_M["CR_Date"] <= end_date) &
                (df_cleaned_M["Tank ID"] == tank)
            ]
            filtered_df_finishing = df_cleaned_F[
                (df_cleaned_F["CR_Date"] >= start_date) &
                (df_cleaned_F["CR_Date"] <= end_date) &
                (df_cleaned_F["Tank ID"] == tank)
            ]
            filtered_df = pd.concat([filtered_df_melting, filtered_df_finishing])

        # 绘制 Defect 数据
        if defect:
            final_df = filtered_df[filtered_df['Defect ID'].isin(defect)]
            for selected_defect in defect:
                df_defect = final_df[final_df['Defect ID'] == selected_defect]
                loss_column = (
                    "M_Defect Loss%" if selected_defect in df_cleaned_M["Defect ID"].unique()
                    else "F_Defect Loss%"
                )
                fig.add_trace(go.Bar(
                    x=df_defect["CR_Date"],
                    y=df_defect[loss_column],
                    name=selected_defect,
                    marker_color=defect_colors.get(selected_defect)
                ))
            fig.update_layout(barmode='stack')
        else:
            raise PreventUpdate

    # 绘制 PI Tag 数据
    if tags and start_date and end_date:
        servername = "grape"
        with PI.PIServer(server=servername) as server:
            points = server.search(tags)
            if len(points) > 0:
                series = []
                for p in points:
                    sampling_interval = '30m' if interval in ['d', 'h'] else interval
                    data = p.interpolated_values(
                        start_time=start_date,
                        end_time=end_date,
                        interval=sampling_interval
                    )
                    interpolated_data = pd.DataFrame(data).reset_index()
                    interpolated_data.columns = ['Timestamp', p.name]
                    interpolated_data['Timestamp'] = pd.to_datetime(interpolated_data['Timestamp'])
                    interpolated_data.set_index('Timestamp', inplace=True)

                    # Resample data
                    resampled_data = interpolated_data.resample(
                        '1D' if interval == 'd' else '1H' if interval == 'h' else interval
                    ).mean()
                    series.append(resampled_data)

                df = pd.concat(series, axis=1)
                color_idx = 0
                for tag in tags:
                    if tag in df.columns:
                        fig.add_trace(go.Scatter(
                            x=df.index,
                            y=df[tag],
                            mode='lines',
                            name=tag,
                            line=dict(color=color_palette[color_idx % len(color_palette)]),
                            yaxis=f"y{axis_count}",
                        ))
                        fig.update_layout(**{
                            f"yaxis{axis_count}": dict(
                                title=tag,
                                overlaying="y",
                                side="right",
                                position=1 - (0.04 * (axis_count - 1))
                            )
                        })
                        axis_count += 1
                        color_idx += 1

    fig.update_layout(
        title=f"{tank} Performance and Process Chart",
        xaxis=dict(title="Date", tickformat='%Y-%m-%d\n%H:%M:%S'),
        yaxis=dict(tickformat='.2%'),
        height=500,
    )
    return fig
