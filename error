import dash
from dash import dcc, html, Input, Output
import pandas as pd
import plotly.express as px
from pyadomd import Pyadomd

# 配置参数
conn_str = "Provider=MSOLAP;Data Source=cgtppd;Catalog=ppd;"

# 初始化 Dash 应用
app = dash.Dash(__name__)

# 获取 Tank ID 选项（静态或从数据库加载）
tank_ids = [f"TC{str(i).zfill(2)}" for i in range(1, 22)]  # 示例 Tank ID 列表

# 布局
app.layout = html.Div([
    html.H1("Defect Loss Analysis"),
    html.Label("Select Tank ID:"),
    dcc.Dropdown(
        id="tank-dropdown",
        options=[{"label": tank, "value": tank} for tank in tank_ids],
        value="TC01",
        clearable=False,
    ),
    html.Label("Select Date Range:"),
    dcc.DatePickerRange(
        id="date-picker",
        start_date="2024-01-01",
        end_date="2024-12-31",
        display_format="YYYY-MM-DD",
    ),
    html.Button("Query", id="query-button", n_clicks=0),
    dcc.Graph(id="defect-loss-graph"),
])

# 回调函数：执行查询并绘图
@app.callback(
    Output("defect-loss-graph", "figure"),
    Input("query-button", "n_clicks"),
    Input("tank-dropdown", "value"),
    Input("date-picker", "start_date"),
    Input("date-picker", "end_date"),
)
def update_graph(n_clicks, tank, start_date, end_date):
    if not tank or not start_date or not end_date:
        return px.scatter(title="Please select valid Tank ID and Date Range.")

    # 格式化日期
    start_date = pd.to_datetime(start_date)
    end_date = pd.to_datetime(end_date)

    # 动态生成 MDX 查询
    query_m = f"""
        SELECT 
            NON EMPTY {{ [Measures].[M_Defect Loss%] }} ON COLUMNS, 
            NON EMPTY {{ ([Time Crate].[CR_Time YQMD].[CR_Date].ALLMEMBERS * 
                          [Tank].[Tank ID].&[{tank}] * 
                          [Defect Tracking].[Defect ID].[Defect ID].ALLMEMBERS) }} 
            DIMENSION PROPERTIES MEMBER_CAPTION, MEMBER_UNIQUE_NAME 
        ON ROWS 
        FROM ( 
            SELECT ({{ [Time Crate].[CR_Date].&[{start_date.strftime("%Y-%m-%dT00:00:00")}] : 
                         [Time Crate].[CR_Date].&[{end_date.strftime("%Y-%m-%dT00:00:00")}] }}) 
            ON COLUMNS 
            FROM [PPD_Actual]
        ) 
        WHERE ( [Defect Tracking].[Defect Group].&[M_Melt Loss] ) 
        CELL PROPERTIES VALUE, BACK_COLOR, FORE_COLOR, FORMATTED_VALUE, FORMAT_STRING, FONT_NAME, FONT_SIZE, FONT_FLAGS
    """

    # 执行查询
    try:
        with Pyadomd(conn_str) as conn:
            with conn.cursor().execute(query_m) as cur:
                # 将查询结果转换为 Pandas DataFrame
                df = pd.DataFrame(cur.fetchall(), columns=[col.name for col in cur.description])

        # 如果查询为空，返回空图表
        if df.empty:
            return px.scatter(title="No data available for the selected Tank ID and Date Range.")

        # 示例数据处理（根据实际返回的列名调整）
        df.columns = ["Date", "Defect ID", "Defect Loss%"]  # 假设列名
        df["Date"] = pd.to_datetime(df["Date"])

        # 绘制图表
        fig = px.line(
            df,
            x="Date",
            y="Defect Loss%",
            color="Defect ID",
            title=f"Defect Loss% for Tank {tank} ({start_date.date()} to {end_date.date()})",
            labels={"Defect Loss%": "Defect Loss (%)"},
        )
        fig.update_layout(xaxis_title="Date", yaxis_title="Defect Loss (%)")
        return fig

    except Exception as e:
        return px.scatter(title=f"Error occurred: {e}")

# 运行应用
if __name__ == "__main__":
    app.run_server(debug=True)
