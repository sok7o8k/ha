@app.callback(
    Output("combined-graph", "figure"),
    Input("tags", "value"),
    Input("date-picker", "value"),  # 直接從日期篩選器獲取值
    Input("interval", "value"),
    Input("tank-picker", "value"),
    Input("loss-type", "value"),
    Input("defect-picker", "value"),
)
def update_combined_graph(tags, date_range, interval, tank, loss_type, defect):
    # 創建一個空的圖表，設定固定顏色板
    fig = go.Figure()
    
    axis_count = 2  # 初始化Y軸數量計數器

    #確保 date_range為有效值
    if not date_range or len(date_range) != 2:
        raise PreventUpdate 
    start_date, end_date = map(pd.to_datetime, date_range)  # 轉換為 datetime 對象

    # 選擇對應數據源並繪製 Loss 部分
    if loss_type != 'none':
        if loss_type == 'melting':
            filtered_df = df_cleaned_M[
                (df_cleaned_M["CR_Date"] >= start_date) &
                (df_cleaned_M["CR_Date"] <= end_date) &
                (df_cleaned_M["Tank ID"] == tank)
            ]
        elif loss_type == 'finishing':
            filtered_df = df_cleaned_F[
                (df_cleaned_F["CR_Date"] >= start_date) &
                (df_cleaned_F["CR_Date"] <= end_date) &
                (df_cleaned_F["Tank ID"] == tank)
            ]
        print(filtered_df)
        # 過濾選定的 Defect ID 並繪製堆疊柱狀圖
        if defect:
            final_df = filtered_df[filtered_df['Defect ID'].isin(defect)]
        for selected_defect in final_df:
            df_defect = final_df[['Defect ID'] == selected_defect]
            print(df_defect) ##here
            fig.add_trace(go.Bar(
                x=df_defect["CR_Date"],
                y=df_defect["M_Defect Loss%"] if loss_type == 'melting' else df_defect["F_Defect Loss%"],
                name=selected_defect
            ))
        fig.update_layout(barmode='stack')
