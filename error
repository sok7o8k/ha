@app.callback(
    Output("combined-graph", "figure"),
    Input("tags", "value"),
    Input("date-picker", "start_date"),
    Input("date-picker", "end_date"),
    Input("interval", "value"),
    Input("tank-picker", "value"),
    Input("loss-type", "value"),
    Input("defect-picker", "value"),
)
def update_combined_graph(tags, start_date, end_date, interval, tank, loss_type, defect):
    fig = go.Figure()

    # 選擇對應數據源並繪製 Loss 部分
    if loss_type != 'none':
        if loss_type == 'melting':
            filtered_df = df_cleaned[
                (pd.to_datetime(df_cleaned["CR_Date"]) >= pd.to_datetime(start_date)) &
                (pd.to_datetime(df_cleaned["CR_Date"]) <= pd.to_datetime(end_date)) &
                (df_cleaned["Tank ID"] == tank)
            ]
        elif loss_type == 'finishing':
            filtered_df = df_finishing_loss_cleaned[
                (pd.to_datetime(df_finishing_loss_cleaned["CR_Date"]) >= pd.to_datetime(start_date)) &
                (pd.to_datetime(df_finishing_loss_cleaned["CR_Date"]) <= pd.to_datetime(end_date)) &
                (df_finishing_loss_cleaned["Tank ID"] == tank)
            ]

        # 過濾選定的 Defect ID 並繪製堆疊柱狀圖
        if defect:
            filtered_df = filtered_df[filtered_df["Defect ID"] == defect]
            fig.add_trace(go.Bar(
                x=filtered_df["CR_Date"],
                y=filtered_df["M_Defect Loss%"] if loss_type == 'melting' else filtered_df["F_Defect Loss%"],
                name=defect
            ))

    # 繪製 PI 數據部分
    if tags:
        for tag in tags:
            pi_data = get_pi_data(tag, start_date, end_date, interval)
            fig.add_trace(go.Scatter(
                x=pi_data["timestamp"],
                y=pi_data["value"],
                mode='lines',
                name=f"PI Data: {tag}"
            ))

    # 配置圖表佈局
    fig.update_layout(
        title="Combined Graph",
        xaxis_title="Date",
        yaxis_title="Value",
        barmode="stack"
    )

    return fig
