def clean_data(df):
    """
    清理從資料庫查詢出來的 DataFrame 資料
    :param df: 原始 DataFrame
    :return: 清理後的 DataFrame
    """
    # 移除以 [MEMBER_UNIQUE_NAME] 結尾的欄位
    cleaned_df = df.loc[:, [col for col in df.columns if not col.endswith("[MEMBER_UNIQUE_NAME]")]]
    
    # 去除 [MEMBER_CAPTION] 後綴，並提取欄位名稱的主體部分
    cleaned_df.columns = [
        col.split(".")[-1][1:-1] if col.endswith("[MEMBER_CAPTION]") else col
        for col in cleaned_df.columns
    ]
    
    # 確保日期列是 datetime 格式
    if "CR_Date" in cleaned_df.columns:
        cleaned_df["CR_Date"] = pd.to_datetime(cleaned_df["CR_Date"], errors="coerce")
    
    return cleaned_df

@app.callback(
    [Output("filtered-data-melting", "data"),
     Output("filtered-data-finishing", "data")],
    [Input("date-picker", "value"),
     Input("tank-picker", "value")]
)
def query_data(date_range, tank):
    if not date_range or not tank:
        raise PreventUpdate  # 如果條件不完整，則不觸發查詢

    start_date, end_date = map(pd.to_datetime, date_range)

    # 查詢 Melting Loss 資料
    query_m = f"""
        SELECT NON EMPTY {{ [Measures].[M_Defect Loss%] }} ON COLUMNS, 
               NON EMPTY {{ ([Time Crate].[CR_Time YQMD].[CR_Date].ALLMEMBERS * 
                             [Tank].[Tank ID].[Tank ID].&[{tank}] *
                             [Defect Tracking].[Defect ID].[Defect ID].ALLMEMBERS) }} 
               DIMENSION PROPERTIES MEMBER_CAPTION, MEMBER_UNIQUE_NAME 
        ON ROWS 
        FROM ( SELECT ({{ [Time Crate].[CR_Date].&[{start_date:%Y-%m-%d}] :
                             [Time Crate].[CR_Date].&[{end_date:%Y-%m-%d}] }}) 
               ON COLUMNS 
               FROM [PPD_Actual]) 
        WHERE ([Time Crate].[CR_Date].CurrentMember)
        CELL PROPERTIES VALUE
    """
    with Pyadomd(conn_str) as conn:
        with conn.cursor().execute(query_m) as cur:
            df_m = pd.DataFrame(cur.fetchall(), columns=[col.name for col in cur.description])

    # 查詢 Finishing Loss 資料
    query_f = f"""
        SELECT NON EMPTY {{ [Measures].[F_Defect Loss%] }} ON COLUMNS, 
               NON EMPTY {{ ([Time Crate].[CR_Time YQMD].[CR_Date].ALLMEMBERS * 
                             [Tank].[Tank ID].[Tank ID].&[{tank}] *
                             [Defect Tracking].[Defect ID].[Defect ID].ALLMEMBERS) }} 
               DIMENSION PROPERTIES MEMBER_CAPTION, MEMBER_UNIQUE_NAME 
        ON ROWS 
        FROM ( SELECT ({{ [Time Crate].[CR_Date].&[{start_date:%Y-%m-%d}] :
                             [Time Crate].[CR_Date].&[{end_date:%Y-%m-%d}] }}) 
               ON COLUMNS 
               FROM [PPD_Actual]) 
        WHERE ([Time Crate].[CR_Date].CurrentMember)
        CELL PROPERTIES VALUE
    """
    with Pyadomd(conn_str) as conn:
        with conn.cursor().execute(query_f) as cur:
            df_f = pd.DataFrame(cur.fetchall(), columns=[col.name for col in cur.description])

    # 數據清理
    df_cleaned_M = clean_data(df_m)
    df_cleaned_F = clean_data(df_f)
    # 將數據轉換為字典格式返回

@app.callback(
    [Output("defect-picker", "options"),  # 更新 defect-picker 的選項
     Output("defect-picker", "value")],  # 更新 defect-picker 的預設值
    Input("loss-type", "value"),         # 當 loss-type 改變時觸發
    Input("tank-picker", "value"),       # 當 tank 改變時也觸發
    Input("date-picker", "value")        # 當日期範圍改變時觸發
)
def update_defect_picker(loss_type, tank, date_range):
    if not date_range or len(date_range) != 2:
        raise PreventUpdate

    start_date, end_date = map(pd.to_datetime, date_range)

    # 合并 melting 和 finishing 数据源
    if loss_type == 'melting+finishing':
        filtered_df_melting = df_cleaned_M[
            (df_cleaned_M["Tank ID"] == tank) &
            (df_cleaned_M["CR_Date"] >= start_date) &
            (df_cleaned_M["CR_Date"] <= end_date)
        ]
        filtered_df_finishing = df_cleaned_F[
            (df_cleaned_F["Tank ID"] == tank) &
            (df_cleaned_F["CR_Date"] >= start_date) &
            (df_cleaned_F["CR_Date"] <= end_date)
        ]
        filtered_df = pd.concat([filtered_df_melting, filtered_df_finishing])
    elif loss_type == 'melting':
        filtered_df = df_cleaned_M[
            (df_cleaned_M["Tank ID"] == tank) &
            (df_cleaned_M["CR_Date"] >= start_date) &
            (df_cleaned_M["CR_Date"] <= end_date)
        ]
    elif loss_type == 'finishing':
        filtered_df = df_cleaned_F[
            (df_cleaned_F["Tank ID"] == tank) &
            (df_cleaned_F["CR_Date"] >= start_date) &
            (df_cleaned_F["CR_Date"] <= end_date)
        ]
    else:
        return [], []

    # 獲取唯一的 Defect ID 選項
    all_defects = filtered_df["Defect ID"].dropna().unique()
    defect_options = [{"label": defect, "value": defect} for defect in all_defects]

    # 默認選中所有 Defect
    default_values = list(all_defects)

    return defect_options, default_values
@app.callback(
    Output("combined-graph", "figure"),
    Input("tags", "value"),
    Input("date-picker", "value"),
    Input("interval", "value"),
    Input("tank-picker", "value"),
    Input("loss-type", "value"),
    Input("defect-picker", "value"),
    Input("pi-y-axis-setting", "value")  # 新增 Y 軸模式輸入
)
def update_combined_graph(tags, date_range, interval, tank, loss_type, defect, pi_y_axis_mode):
    fig = go.Figure()

    if not date_range or len(date_range) != 2:
        raise PreventUpdate
    start_date, end_date = map(pd.to_datetime, date_range)

    # 处理 Loss 数据
    if loss_type in ['melting', 'finishing', 'melting+finishing']:
        if loss_type == 'melting':
            filtered_df = df_cleaned_M[
                (df_cleaned_M["CR_Date"] >= start_date) &
                (df_cleaned_M["CR_Date"] <= end_date) &
                (df_cleaned_M["Tank ID"] == tank)
            ]
        elif loss_type == 'finishing':
            filtered_df = df_cleaned_F[
                (df_cleaned_F["CR_Date"] >= start_date) &
                (df_cleaned_F["CR_Date"] <= end_date) &
                (df_cleaned_F["Tank ID"] == tank)
            ]
        elif loss_type == 'melting+finishing':
            filtered_df_melting = df_cleaned_M[
                (df_cleaned_M["CR_Date"] >= start_date) &
                (df_cleaned_M["CR_Date"] <= end_date) &
                (df_cleaned_M["Tank ID"] == tank)
            ]
            filtered_df_finishing = df_cleaned_F[
                (df_cleaned_F["CR_Date"] >= start_date) &
                (df_cleaned_F["CR_Date"] <= end_date) &
                (df_cleaned_F["Tank ID"] == tank)
            ]
            filtered_df = pd.concat([filtered_df_melting, filtered_df_finishing])
        print(filtered_df)
        # 繪製 Defect
        if defect:
            final_df = filtered_df[filtered_df['Defect ID'].isin(defect)]
            for selected_defect in defect:
                df_defect = final_df[final_df['Defect ID'] == selected_defect]
                loss_column = (
                    "M_Defect Loss%" if selected_defect in df_cleaned_M["Defect ID"].unique()
                    else "F_Defect Loss%"
                )
                fig.add_trace(go.Bar(
                    x=df_defect["CR_Date"],
                    y=df_defect[loss_column],
                    name=selected_defect,
                    marker_color=defect_colors.get(selected_defect)
                ))
            fig.update_layout(barmode='stack')
        else:
            pass
    else:
        pass
    return df_cleaned_M.to_dict("records"), df_cleaned_F.to_dict("records")
